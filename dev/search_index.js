var documenterSearchIndex = {"docs":
[{"location":"readers/#AbstractBufReader","page":"Readers","title":"AbstractBufReader","text":"","category":"section"},{"location":"readers/#Core,-low-level-interface","page":"Readers","title":"Core, low-level interface","text":"The core interface of an io::AbstractBufReader consists of three functions, that are to be used together:\n\nget_buffer(io) returns a view into the internal buffer with data ready to read. You read from the io by copying.\nfill_buffer(io) attempts to append more bytes to the buffer returned by future calls to get_buffer\nconsume(io, n::Int) removes the first n bytes of the buffer from future buffers returned by get_buffer\n\nWhile lots of higher-level convenience functions are also defined, nearly all functionality is defined in terms of these three core functions. See the docstrings of these functions for details and edge cases.\n\nLet's see two use cases to demonstrate how this core interface is used.","category":"section"},{"location":"readers/#Example:-Reading-N-bytes","page":"Readers","title":"Example: Reading N bytes","text":"Suppose we want a function read_exact(io::AbstractBufReader, n::Int) which reads exactly n bytes to a new Vector{UInt8}, unless io hits end-of-file (EOF).\n\nThis functionality is already implemented as read(::AbstractBufReader, ::Integer), so the below implementation is for illustration purposes.\n\nSince io itself controls how many bytes are filled with fill_buffer (typically whatever is the most efficient), we do this best by calling the functions above in a loop:\n\nfunction read_exact(io::AbstractBufReader, n::Int)\n    n > -1 || throw(ArgumentError(\"n must be non-negative\"))\n    result = sizehint!(UInt8[], n)\n    remaining = n\n    while !iszero(remaining)\n        # Get the buffer to copy bytes from in order to read from `io`\n        buffer = get_buffer(io)\n        if isempty(buffer)\n            # Fill new bytes into the buffer. This returns `0` if `io` if EOF,\n            # in which case we break to return the result.\n            # `fill_buffer` can return `nothing` for some reader types, but only if\n            # the buffer is not empty.\n            iszero(something(fill_buffer(io))) && break\n            buffer = get_buffer(io)\n        end\n        mn = min(remaining, length(buffer))\n        append!(result, buffer[1:mn])\n        # Signal to `io` that the first `mn` bytes have already been read,\n        # so these should not be output in future calls to `get_buffer`\n        consume(io, mn)\n        remaining -= mn\n    end\n    return result\nend\n\nThe code above may be simplified by using the convenience function get_nonempty_buffer or by simply calling the already-implemented read(io, n).","category":"section"},{"location":"readers/#Example:-Reading-a-line-without-intermediate-allocations","page":"Readers","title":"Example: Reading a line without intermediate allocations","text":"In this example, we want to buffer a full line in io's buffer, and then return a view into the buffer representing that line.\n\nThis function is an unusual use case, because we need to ensure the buffer is able to hold a full line. For most IO operations, we do not need, nor want to control exactly how much is buffered by io, since leaving that up to io is typically more efficient.\n\nTherefore, this is one of the rare cases where we may need to force io to grow its buffer.\n\nfunction get_line_view(io::AbstractBufReader)\n    # Which position to search for a newline from\n    scan_from = 1\n    while true\n        buffer = get_buffer(io)\n        pos = findnext(==(UInt8('\\n')), buffer, scan_from)\n        if pos === nothing\n            scan_from = length(buffer) + 1\n            n_filled = fill_buffer(io)\n            if n_filled === nothing\n                # fill_buffer may return nothing if the buffer is not empty,\n                # and the buffer cannot be expanded further.\n                error(\"io could not buffer an entire line\")\n            elseif iszero(n_filled)\n                # This indicates EOF, so the line is defined as the rest of the\n                # content of `io`\n                return buffer\n            end\n        else\n            return buffer[1:pos]\n        end\n    end\nend\n\nFunctionality similar to the above is provided by the line_views iterator.","category":"section"},{"location":"readers/#Notable-AbstractReader-functions","page":"Readers","title":"Notable AbstractReader functions","text":"AbstractBufReader implements most of the Base.IO interface, see the section in the sidebar. They also have a few special convenience functions:","category":"section"},{"location":"readers/#BufferIO.get_buffer-readers","page":"Readers","title":"BufferIO.get_buffer","text":"get_buffer(io::AbstractBufReader)::ImmutableMemoryView{UInt8}\n\nGet the available bytes of io.\n\nCalling this function, even when the buffer is empty, should never do actual system I/O, and in particular should not attempt to fill the buffer. To fill the buffer, call fill_buffer.\n\nExamples\n\njulia> reader = BufReader(IOBuffer(\"abcdefghij\"), 5);\n\njulia> get_buffer(reader) |> isempty\ntrue\n\njulia> fill_buffer(reader)\n5\n\njulia> get_buffer(reader) |> println\nUInt8[0x61, 0x62, 0x63, 0x64, 0x65]\n\n\n\n\n\nget_buffer(io::AbstractBufWriter)::MutableMemoryView{UInt8}\n\nGet the available mutable buffer of io that can be written to.\n\nCalling this function should never do actual system I/O, and in particular should not attempt to flush data from the buffer or grow the buffer. To increase the size of the buffer, call grow_buffer.\n\nExamples\n\njulia> writer = BufWriter(IOBuffer(), 5);\n\njulia> buffer = get_buffer(writer);\n\njulia> (typeof(buffer), length(buffer))\n(MutableMemoryView{UInt8}, 5)\n\njulia> write(writer, \"abcde\")\n5\n\njulia> get_buffer(writer) |> isempty\ntrue\n\njulia> flush(writer)\n\njulia> buffer = get_buffer(writer); length(buffer)\n5\n\n\n\n\n\n","category":"function"},{"location":"readers/#BufferIO.fill_buffer-readers","page":"Readers","title":"BufferIO.fill_buffer","text":"fill_buffer(io::AbstractBufReader)::Union{Int, Nothing}\n\nFill more bytes into the buffer from io's underlying buffer, returning the number of bytes added. After calling fill_buffer and getting n, the buffer obtained by get_buffer should have n new bytes appended.\n\nThis function must fill at least one byte, except\n\nIf the underlying io is EOF, or there is no underlying io to fill bytes from, return 0\nIf the buffer is not empty, and cannot be expanded, return nothing.\n\nBuffered readers which do not wrap another underlying IO, and therefore can't fill its buffer should return 0 unconditionally. This function should never return nothing if the buffer is empty.\n\nnote: Note\nIdiomatically, users should not call fill_buffer when the buffer is not empty, because doing so may force growing the buffer instead of letting io choose an optimal buffer size. Calling fill_buffer with a nonempty buffer is only appropriate if, for algorithmic reasons you need io itself to buffer some minimum amount of data.\n\nExamples\n\njulia> reader = CursorReader(\"abcde\");\n\njulia> fill_buffer(reader) # CursorReader can't fill its buffer\n0\n\njulia> reader = BufReader(IOBuffer(\"abcde\"), 3);\n\njulia> length(get_buffer(reader)) # buffer of BufReader initially empty\n0\n\njulia> fill_buffer(reader)\n3\n\njulia> length(get_buffer(reader)) # now must be 0 + 3\n3\n\n\n\n\n\n","category":"function"},{"location":"readers/#BufferIO.consume-readers","page":"Readers","title":"BufferIO.consume","text":"consume(io::Union{AbstractBufReader, AbstractBufWriter}, n::Int)::Nothing\n\nRemove the first n bytes of the buffer of io. Consumed bytes will not be returned by future calls to get_buffer.\n\nIf n is negative, or larger than the current buffer size, throw an IOError with ConsumeBufferError kind. This check is a boundscheck and may be elided with @inbounds.\n\nExamples\n\njulia> reader = CursorReader(\"abcdefghij\");\n\njulia> get_buffer(reader) == b\"abcdefghij\"\ntrue\n\njulia> consume(reader, 8); get_buffer(reader) |> println\nUInt8[0x69, 0x6a]\n\njulia> consume(reader, 3) # 2 bytes remaining\nERROR: Called `consume` with a negative amount, or larger than available buffer size\n\n\n\n\n\n","category":"function"},{"location":"readers/#BufferIO.get_nonempty_buffer-Tuple{AbstractBufReader}-readers","page":"Readers","title":"BufferIO.get_nonempty_buffer","text":"get_nonempty_buffer(x::AbstractBufReader)::Union{Nothing, ImmutableMemoryView{UInt8}}\n\nGet a buffer with at least one byte, if bytes are available. Otherwise, fill the buffer, and return the newly filled buffer. Returns nothing only if x is EOF.\n\nExamples\n\njulia> reader = BufReader(IOBuffer(\"abc\"));\n\njulia> get_buffer(reader) |> isempty\ntrue\n\njulia> get_nonempty_buffer(reader) |> println\nUInt8[0x61, 0x62, 0x63]\n\njulia> consume(reader, 3)\n\njulia> get_nonempty_buffer(reader) === nothing # EOF\ntrue\n\n\n\n\n\n","category":"method"},{"location":"readers/#BufferIO.read_into!-readers","page":"Readers","title":"BufferIO.read_into!","text":"read_into!(x::AbstractBufReader, dst::MutableMemoryView{UInt8})::Int\n\nRead bytes into the beginning of dst, returning the number of bytes read. This function will always read at least 1 byte, except when dst is empty, or x is EOF.\n\nThis function is defined generically for AbstractBufReader. New methods should strive to do at most one read call to the underlying IO, if x wraps such an IO.\n\nExamples\n\njulia> reader = CursorReader(\"abcde\");\n\njulia> v = zeros(UInt8, 8);\n\njulia> read_into!(reader, MemoryView(v))\n5\n\njulia> println(v)\nUInt8[0x61, 0x62, 0x63, 0x64, 0x65, 0x00, 0x00, 0x00]\n\n\n\n\n\n","category":"function"},{"location":"readers/#BufferIO.read_all!-readers","page":"Readers","title":"BufferIO.read_all!","text":"read_all!(io::AbstractBufReader, dst::MutableMemoryView{UInt8})::Int\n\nRead bytes into dst until either dst is filled or io is EOF, returning the number of bytes read.\n\nExamples\n\njulia> reader = BufReader(IOBuffer(\"abcdefgh\"), 3);\n\njulia> v = zeros(UInt8, 10);\n\njulia> read_all!(reader, MemoryView(v))\n8\n\njulia> String(v)\n\"abcdefgh\\0\\0\"\n\n\n\n\n\n","category":"function"},{"location":"examples/#Example-use-of-BufferIO","page":"Examples","title":"Example use of BufferIO","text":"","category":"section"},{"location":"examples/#Examples-in-the-wild","page":"Examples","title":"Examples in the wild","text":"At the time of writing, BufferIO is a brand-new package with limited usage in the Julia ecosystem.\n\nSo far, the users of BufferIO are:\n\nBGZFLib.jl","category":"section"},{"location":"examples/#Reader-example","page":"Examples","title":"Reader example","text":"For bulk I/O operations, there is often not much practical difference between Base.IO and the BufferIO interfaces - except somewhat more precise semantics of the latter.\n\nWhere BufferIO really shines are when you need to read and parse at the same time. For example, suppose you need to read a non-negative decimal number from an io object. You need to figure out where the number ends, before reading it, lest you read too many bytes. With a Base.IO type, your choices are:\n\nRead one byte at a time, which is inefficient\nImplement your own buffering layer, and load data into the buffer, then read the number from the buffer.\n\nThe latter is essentially an ad-hoc implementation of a BufferIO-like interface. This is what packages like FASTX.jl, XAM.jl and other parsing packages do.\n\nBelow is an implementation of how to do it using BufferIO.\n\nusing BufferIO, StringViews, MemoryViews\n\nis_decimal(x::UInt8) = in(x, UInt8('0'):UInt8('9'))\n\nfunction read_decimal_number(io::AbstractBufReader)::Union{Int, Nothing}\n    scan_from = 1\n    buffer = get_buffer(io)\n    local non_digit_pos\n    # Keep expanding buffer until we reach EOF, or find the first non-digit\n    while true\n        non_digit_pos = findnext(!is_decimal, buffer, scan_from)\n        if isnothing(non_digit_pos)\n            # Next iteration, do not re-scan the same bytes to find end of number\n            scan_from = length(buffer) + 1\n            n_filled = fill_buffer(io)\n            # `nothing` means buffer could not grow. Many subtypes of `AbstractBufReader`\n            # will never return this, in which case this error branch is compiled away\n            isnothing(n_filled) && throw(IOError(IOErrorKinds.BufferTooShort))\n            # This indicates EOF, so we attempt to parse the rest of the line\n            if iszero(n_filled)\n                non_digit_pos = lastindex(buffer) + 1\n                break\n            end\n            buffer = get_buffer(io)\n            # Check `fill_buffer` was implemented correctly\n            @assert length(buffer) â‰¥ scan_from\n        else\n            break\n        end\n    end\n    # If no digit was found, do not attempt to parse\n    non_digit_pos == 1 && return nothing\n    # Rely on existing Base parsing functionality to throw e.g. overflow\n    # errors. Since this is validated data of a known type, a custom implementation\n    # could be much faster.\n    digit = parse(Int, StringView(buffer[1:non_digit_pos - 1]))\n    consume(io, non_digit_pos - 1)\n    return digit\nend","category":"section"},{"location":"examples/#Writer-example","page":"Examples","title":"Writer example","text":"Similar to the above example, where BufferIO's principle of the buffer is the interface enabled integrating reading and parsing for a more efficient API, BufferIO's writer shine when you can write data directly into a buffer without any intermediate allocations.\n\nFor example, currently, writing a number to an IOBuffer allocates. This is because the number is first heap-allocated, and then data from the heap is copied into the io. In contrast, BufferIO provides the the a buffer to write into directly.\n\nusing BufferIO, MemoryViews\n\n# Constrain the signature to types of a known binary layout which we can copy\n# directly using a pointer\nconst BitInteger = Union{Int, UInt...}\n\nfunction write(io::AbstractBufWriter, n::BitInteger)\n    buffer = get_buffer(io)\n    while length(buffer) < sizeof(n)\n        n_filled = grow_buffer(io)\n        iszero(n_filled) && throw(IOError(IOErrorKinds.BufferTooShort))\n        buffer = get_buffer(io)\n    end\n    GC.@preserve buffer unsafe_store!(Ptr{typeof(n)}(pointer(buffer)), n)\n    consume(io, sizeof(n))\n    return sizeof(n)\nend\n\nFor types that implement the two-arg method of get_nonempty_buffer, ","category":"section"},{"location":"reference/#Reference","page":"API reference","title":"Reference","text":"","category":"section"},{"location":"reference/#BufferIO.AbstractBufReader","page":"API reference","title":"BufferIO.AbstractBufReader","text":"abstract type AbstractBufReader end\n\nAn AbstractBufReader is a readable IO type that exposes a buffer of readable bytes to the user.\n\nwarning: Warning\nBy default, subtypes of AbstractBufReader are not threadsafe, so concurrent usage should protect the instance behind a lock.\n\nExtended help\n\nSubtypes of this type should not have a zero-sized buffer which cannot expand when calling fill_buffer.\n\nSubtypes T of this type should implement at least:\n\nget_buffer(io::T)\nfill_buffer(io::T)\nconsume(io::T, n::Int)\nBase.close(io::T)\n\nSubtypes may optionally define the following methods. See their docstring for BufReader / BufWriter for details of the implementation:\n\nBase.seek(io::T, ::Int)\nBase.filesize(io::T)\nBase.position(io::T)\nresize_buffer(io::T, ::Int)\n\nAbstractBufReaders have implementations for many Base IO methods, but with more precisely specified semantics than for Base.IO. See docstrings of the specific functions of interest.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.AbstractBufWriter","page":"API reference","title":"BufferIO.AbstractBufWriter","text":"abstract type AbstractBufWriter end\n\nAn AbstractBufWriter is an IO-like type which exposes mutable memory to the user, which can be written to directly. This can help avoiding intermediate allocations when writing. For example, integers can usually be written to buffered writers without allocating. \n\nwarning: Warning\nBy default, subtypes of AbstractBufWriter are not threadsafe, so concurrent usage should protect the instance behind a lock.\n\nExtended help\n\nSubtypes of this type should not have a zero-sized buffer which cannot expand when calling grow_buffer.\n\nSubtypes T of this type should implement at least:\n\nget_buffer(io::T)\ngrow_buffer(io::T)\nconsume(io::T, n::Int)\nBase.close(io::T)\nBase.flush(io::T)\n\nThey may optionally implement\n\nBase.seek(io::T, ::Int)\nBase.filesize(io::T)\nBase.position(io::T)\nget_unflushed(io::T)\nshallow_flush(io::T)\nresize_buffer(io::T, ::Int)\nget_nonempty_buffer(io::T, ::Int)\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.BufReader","page":"API reference","title":"BufferIO.BufReader","text":"BufReader(f, io::IO, [buffer_size::Int])\n\nCreate a BufReader wrapping io, then call f on the BufReader, and close the reader once f is finished or if it errors.\n\nThis pattern is useful for automatically cleaning up the resource of io.\n\njulia> io = IOBuffer(\"hello world\");\n\njulia> BufReader(io) do reader\n           println(String(read(io, 5)))\n       end\nhello\n\njulia> read(io) # closing reader closes io also\nERROR: ArgumentError: read failed, IOBuffer is not readable\n[...]\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.BufReader-2","page":"API reference","title":"BufferIO.BufReader","text":"BufReader{T <: IO} <: AbstractBufReader\nBufReader(io::IO, [buffer_size::Int])::BufReader\n\nWrap an IO in a struct with a new buffer, giving it the AbstractBufReader interface.\n\nThe BufReader has an infinitely growable buffer, and will only grow the buffer if fill_buffer is called while its internal buffer is full.\n\nThrow an ArgumentError if buffer_size is less than 1.\n\njulia> rdr = BufReader(IOBuffer(\"Hello, world!\\nabc\\r\\ndef\"));\n\njulia> get_buffer(rdr) |> isempty\ntrue\n\njulia> peek(rdr)\n0x48\n\njulia> readline(rdr)\n\"Hello, world!\"\n\njulia> String(readavailable(rdr))\n\"abc\\r\\ndef\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.BufWriter","page":"API reference","title":"BufferIO.BufWriter","text":"BufWriter(f, io::IO, [buffer_size::Int])\n\nCreate a BufWriter wrapping io, then call f on the BufWriter, and close the writer once f is finished or if it errors.\n\nThis pattern is useful for automatically cleaning up the resource of io.\n\njulia> io = IOBuffer();\n\njulia> BufWriter(io) do writer\n           write(writer, \"hello, world!\")\n           shallow_flush(writer)\n           seekstart(io)\n           println(String(read(io)))\n       end\nhello, world!\n\njulia> iswritable(io) # closing reader closes io also\nfalse\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.BufWriter-2","page":"API reference","title":"BufferIO.BufWriter","text":"BufWriter{T <: IO} <: AbstractBufWriter\nBufWriter(io::IO, [buffer_size::Int])::BufWriter\n\nWrap an IO in a struct with a new buffer, giving it the AbstractBufWriter interface.\n\nThe BufWriter has an infinitely growable buffer, and will only expand the buffer if grow_buffer is called on it while it does not contain any data (as shown by get_unflushed).\n\nThrow an ArgumentError if buffer_size is < 1.\n\njulia> io = IOBuffer(); wtr = BufWriter(io);\n\njulia> print(wtr, \"Hello!\")\n\njulia> write(wtr, [0x1234, 0x5678])\n4\n\njulia> isempty(read(io)) # wtr not flushed\ntrue\n\njulia> flush(wtr); seekstart(io); String(read(io))\n\"Hello!4\\x12xV\"\n\njulia> isempty(get_unflushed(wtr))\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.ByteVector","page":"API reference","title":"BufferIO.ByteVector","text":"ByteVector <: DenseVector{UInt8}\n\nA re-implementation of Vector{UInt8} that only supports a subset of its methods. In future minor releases, this may change to be an alias of Vector{UInt8}.\n\nNote that String(x::ByteVector) will truncate x, to mirror the behaviour of String(::Vector{UInt8}). It is recommended to use takestring! instead.\n\nAll Base methods implemented for ByteVector is guaranteed to have the same semantics as those for Vector. Futhermore, ByteVector supports:\n\ntakestring!(::ByteVector) even on Julia < 1.13, whereas takestring!(::Vector{UInt8}) is only defined from Julia 1.13 onwards.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.CursorReader","page":"API reference","title":"BufferIO.CursorReader","text":"CursorReader(x) <: AbstractBufReader\n\nA seekable, stateful reader of the content of any object x which implements MemoryView(x)::MemoryView{UInt8}.\n\nClosing it does nothing.\n\njulia> rdr = CursorReader(\"some\\ncontent\\nhere\");\n\njulia> readline(rdr)\n\"some\"\n\njulia> read(rdr, String)\n\"content\\nhere\"\n\njulia> seek(rdr, 8);\n\njulia> read(rdr, String)\n\"tent\\nhere\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.IOError","page":"API reference","title":"BufferIO.IOError","text":"IOError\n\nThis type is thrown by errors of AbstractBufReader. They contain the .kind::IOErrorKind public property.\n\nSee also: IOErrorKinds.IOErrorKind\n\nExamples\n\njulia> rdr = CursorReader(\"some content\");\n\njulia> try\n           seek(rdr, 500)\n       catch error\n           if error.kind == IOErrorKinds.BadSeek\n               println(stderr, \"Seeking operation out of bounds\")\n           else\n               rethrow()\n           end\n        end\nSeeking operation out of bounds\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.IOReader","page":"API reference","title":"BufferIO.IOReader","text":"IOReader{T <: AbstractBufReader} <: IO\n\nWrapper type to convert an AbstractBufReader to an IO.\n\nIOReaders implement the same part of the IO interface as AbstractBufReader, so this type is only used to satisfy type constraints.\n\nExamples\n\njulia> io = CursorReader(\"hello\");\n\njulia> f(x::IO) = String(read(x));\n\njulia> f(io)\nERROR: MethodError: no method matching f(::CursorReader)\n[...]\n\njulia> f(IOReader(io))\n\"hello\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.IOWriter","page":"API reference","title":"BufferIO.IOWriter","text":"IOWriter{T <: AbstractBufWriter} <: IO\n\nWrapper type to convert an AbstractBufWriter to an IO.\n\nIOWriters implement the same part of the IO interface as AbstractBufWriter, so this type is only used to satisfy type constraints.\n\nExamples\n\njulia> io = VecWriter();\n\njulia> f(x::IO) = write(x, \"hello\");\n\njulia> f(io)\nERROR: MethodError: no method matching f(::VecWriter)\n[...]\n\njulia> f(IOWriter(io))\n5\n\njulia> String(io.vec)\n\"hello\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.VecWriter","page":"API reference","title":"BufferIO.VecWriter","text":"VecWriter <: AbstractBufWriter\n\nA writer backed by a ByteVector. Read the (public) property .vec to get the vector back.\n\nThis type is useful as an efficient string builder through takestring!(io).\n\nFunctions flush and close do not affect the writer.\n\nMutating io will mutate vec and vice versa. Neither vec nor io will be invalidated by mutating the other, but doing so may affect the implicit (non-semantic) behaviour (e.g. memory reallocations or efficiency) of the other. For example, repeated and interleaved push!(vec) and write(io, x) may be less efficient, if one operation has memory allocation patterns that is suboptimal for the other operation.\n\nCreate with one of the following constructors:\n\nVecWriter([vec::Vector{UInt8}])\nVecWriter(undef, ::Int)\nVecWriter(::ByteVector)\n\nNote that, currently, when constructing from a Vector{UInt8}, the vector is invalidated and the VecWriter and its wrapped ByteVector take shared control of the underlying memory. This restriction may be lifted in the future.\n\nA VecWriter has no notion of filesize, and cannot be seeked. Instead, resize the underlying vector io.vec.\n\njulia> vw = VecWriter();\n\njulia> write(vw, \"Hello, world!\", 0xe1fa)\n15\n\njulia> append!(vw.vec, b\"More data\");\n\njulia> String(vw.vec)\n\"Hello, world!\\xfa\\xe1More data\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.consume","page":"API reference","title":"BufferIO.consume","text":"consume(io::Union{AbstractBufReader, AbstractBufWriter}, n::Int)::Nothing\n\nRemove the first n bytes of the buffer of io. Consumed bytes will not be returned by future calls to get_buffer.\n\nIf n is negative, or larger than the current buffer size, throw an IOError with ConsumeBufferError kind. This check is a boundscheck and may be elided with @inbounds.\n\nExamples\n\njulia> reader = CursorReader(\"abcdefghij\");\n\njulia> get_buffer(reader) == b\"abcdefghij\"\ntrue\n\njulia> consume(reader, 8); get_buffer(reader) |> println\nUInt8[0x69, 0x6a]\n\njulia> consume(reader, 3) # 2 bytes remaining\nERROR: Called `consume` with a negative amount, or larger than available buffer size\n\n\n\n\n\n","category":"function"},{"location":"reference/#BufferIO.fill_buffer","page":"API reference","title":"BufferIO.fill_buffer","text":"fill_buffer(io::AbstractBufReader)::Union{Int, Nothing}\n\nFill more bytes into the buffer from io's underlying buffer, returning the number of bytes added. After calling fill_buffer and getting n, the buffer obtained by get_buffer should have n new bytes appended.\n\nThis function must fill at least one byte, except\n\nIf the underlying io is EOF, or there is no underlying io to fill bytes from, return 0\nIf the buffer is not empty, and cannot be expanded, return nothing.\n\nBuffered readers which do not wrap another underlying IO, and therefore can't fill its buffer should return 0 unconditionally. This function should never return nothing if the buffer is empty.\n\nnote: Note\nIdiomatically, users should not call fill_buffer when the buffer is not empty, because doing so may force growing the buffer instead of letting io choose an optimal buffer size. Calling fill_buffer with a nonempty buffer is only appropriate if, for algorithmic reasons you need io itself to buffer some minimum amount of data.\n\nExamples\n\njulia> reader = CursorReader(\"abcde\");\n\njulia> fill_buffer(reader) # CursorReader can't fill its buffer\n0\n\njulia> reader = BufReader(IOBuffer(\"abcde\"), 3);\n\njulia> length(get_buffer(reader)) # buffer of BufReader initially empty\n0\n\njulia> fill_buffer(reader)\n3\n\njulia> length(get_buffer(reader)) # now must be 0 + 3\n3\n\n\n\n\n\n","category":"function"},{"location":"reference/#BufferIO.get_buffer-Tuple{BufReader}","page":"API reference","title":"BufferIO.get_buffer","text":"get_buffer(io::AbstractBufReader)::ImmutableMemoryView{UInt8}\n\nGet the available bytes of io.\n\nCalling this function, even when the buffer is empty, should never do actual system I/O, and in particular should not attempt to fill the buffer. To fill the buffer, call fill_buffer.\n\nExamples\n\njulia> reader = BufReader(IOBuffer(\"abcdefghij\"), 5);\n\njulia> get_buffer(reader) |> isempty\ntrue\n\njulia> fill_buffer(reader)\n5\n\njulia> get_buffer(reader) |> println\nUInt8[0x61, 0x62, 0x63, 0x64, 0x65]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.get_buffer-Tuple{BufWriter}","page":"API reference","title":"BufferIO.get_buffer","text":"get_buffer(io::AbstractBufWriter)::MutableMemoryView{UInt8}\n\nGet the available mutable buffer of io that can be written to.\n\nCalling this function should never do actual system I/O, and in particular should not attempt to flush data from the buffer or grow the buffer. To increase the size of the buffer, call grow_buffer.\n\nExamples\n\njulia> writer = BufWriter(IOBuffer(), 5);\n\njulia> buffer = get_buffer(writer);\n\njulia> (typeof(buffer), length(buffer))\n(MutableMemoryView{UInt8}, 5)\n\njulia> write(writer, \"abcde\")\n5\n\njulia> get_buffer(writer) |> isempty\ntrue\n\njulia> flush(writer)\n\njulia> buffer = get_buffer(writer); length(buffer)\n5\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.get_nonempty_buffer-Tuple{AbstractBufReader}","page":"API reference","title":"BufferIO.get_nonempty_buffer","text":"get_nonempty_buffer(x::AbstractBufReader)::Union{Nothing, ImmutableMemoryView{UInt8}}\n\nGet a buffer with at least one byte, if bytes are available. Otherwise, fill the buffer, and return the newly filled buffer. Returns nothing only if x is EOF.\n\nExamples\n\njulia> reader = BufReader(IOBuffer(\"abc\"));\n\njulia> get_buffer(reader) |> isempty\ntrue\n\njulia> get_nonempty_buffer(reader) |> println\nUInt8[0x61, 0x62, 0x63]\n\njulia> consume(reader, 3)\n\njulia> get_nonempty_buffer(reader) === nothing # EOF\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.get_nonempty_buffer-Tuple{AbstractBufWriter}","page":"API reference","title":"BufferIO.get_nonempty_buffer","text":"get_nonempty_buffer(x::AbstractBufWriter)::Union{Nothing, MutableMemoryView{UInt8}}\n\nGet a buffer with at least one byte, if bytes are available. Otherwise, call grow_buffer, then get the buffer again. Returns nothing if the buffer is still empty.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.get_nonempty_buffer-Tuple{VecWriter, Int64}","page":"API reference","title":"BufferIO.get_nonempty_buffer","text":"get_nonempty_buffer(\n    io::AbstractBufWriter, min_size::Int\n)::Union{Nothing, MutableMemoryView{UInt8}}\n\nGet a buffer of at least size max(min_size, 1), or nothing if that is not possible.\n\nThis method is optionally implemented for subtypes of AbstractBufWriter, and is typically only implemented for types which do not flush their data to an underlying IO, such that there is no memory savings by writing in smaller chunks.\n\nwarning: Warning\nUse of this method may cause excessive buffering without flushing, which is less memory efficient than calling the one-argument method and flushing in a loop.\n\nExamples\n\njulia> function write_int_le(writer::AbstractBufWriter, int::Int64)\n           buf = get_nonempty_buffer(writer, sizeof(Int64))::Union{Nothing, MutableMemoryView{UInt8}}\n           isnothing(buf) && throw(IOError(IOErrorKinds.BufferTooShort))\n           length(buf) < sizeof(Int64) && error(\"Bad implementation of get_nonempty_buffer\")\n           GC.@preserve buf unsafe_store!(Ptr{Int64}(pointer(buf)), htol(int))\n           @inbounds consume(writer, sizeof(Int64))\n           return sizeof(Int64)\n       end;\n\njulia> v = VecWriter(); write_int_le(v, Int64(515))\n8\n\njulia> String(v.vec)\n\"\\x03\\x02\\0\\0\\0\\0\\0\\0\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.get_unflushed-Tuple{BufWriter}","page":"API reference","title":"BufferIO.get_unflushed","text":"get_unflushed(io::AbstractBufWriter)::MutableMemoryView{UInt8}\n\nReturn a view into the buffered data already written to io and consumed, but not yet flushed to its underlying IO.\n\nBytes not appearing in the buffer may not be completely flushed if there are more layers of buffering in the IO wrapped by io. However, any bytes already consumed and not returned in get_unflushed should not be buffered in io itself.\n\nMutating the returned buffer is allowed, and should not cause io to malfunction. After mutating the returned buffer and calling flush, values in the updated buffer will be flushed.\n\nThis function has no default implementation and methods are optionally added to subtypes of AbstractBufWriter that can fullfil the above restrictions.\n\nExamples\n\njulia> io = IOBuffer(); writer = BufWriter(io);\n\njulia> isempty(get_unflushed(writer))\ntrue\n\njulia> write(writer, \"abc\"); unflushed = get_unflushed(writer);\n\njulia> println(unflushed)\nUInt8[0x61, 0x62, 0x63]\n\njulia> unflushed[2] = UInt8('x')\n0x78\n\njulia> flush(writer); take!(io) |> println\nUInt8[0x61, 0x78, 0x63]\n\njulia> get_unflushed(writer) |> isempty\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.grow_buffer-Tuple{BufWriter}","page":"API reference","title":"BufferIO.grow_buffer","text":"grow_buffer(io::AbstractBufWriter)::Int\n\nIncrease the amount of bytes in the writeable buffer of io if possible, returning the number of bytes added. After calling grow_buffer and getting n, the buffer obtained by get_buffer should have n more bytes.\n\nThe buffer is usually grown by flushing the buffer, expanding or reallocating the buffer. If none of these can grow the buffer, return zero.\n\nnote: Note\nIdiomatically, users should not call grow_buffer when the buffer is not empty, because doing so forces growing the buffer instead of letting io choose an optimal buffer size. Calling grow_buffer with a nonempty buffer is only appropriate if, for algorithmic reasons you need io buffer to be able to hold some minimum amount of data before flushing.\n\nExamples\n\njulia> v = VecWriter(undef, 0); get_buffer(v) |> isempty\ntrue\n\njulia> n_grown = grow_buffer(v); n_grown > 0\ntrue\n\njulia> length(get_buffer(v)) == n_grown\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.line_views-Tuple{AbstractBufReader}","page":"API reference","title":"BufferIO.line_views","text":"line_views(x::AbstractBufReader; chomp::Bool=true)\n\nCreate an efficient iterator of lines of x. The returned views are ImmutableMemoryView{UInt8} views into x's buffer,  and are invalidated when x is mutated or the line iterator is advanced.\n\nWhen iterating the iterator, x is not advanced on the first call to iterate. Subsequent calls will advance x to get the next line, thus invalidating the previous line view.\n\nA line is defined as all data up to and including \\n (0x0a) or \\r\\n (0x0d 0x0a), or the remainder of the data in io if no \\n byte was found. If the input is empty, this iterator is also empty.\n\nThe lines are iterated as ImmutableMemoryView{UInt8}. Use the package StringViews.jl to turn them into AbstractStrings. The chomp keyword (default: true), controls whether any trailing \\r\\n or \\n should be removed from the output.\n\nIf x had a limited buffer size, and an entire line cannot be kept in the buffer, an ArgumentError is thrown.\n\nThe resulting iterator will NOT close x when done, this must be handled by the caller.\n\nExamples\n\njulia> lines = line_views(CursorReader(\"abc\\r\\ndef\\n\\r\\ngh\"));\n\njulia> (line, state) = iterate(lines); String(line)\n\"abc\"\n\njulia> println(first(lines)) # not advanced until 2-arg iterate call\nUInt8[0x61, 0x62, 0x63]\n\njulia> iterate(lines, state) |> first |> String # advance to \"def\"\n\"def\"\n\njulia> line = nothing # `line` is now invalidated\n\njulia> sum(length, lines) # \"def\" + \"\" + \"gh\"\n5\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.line_views-Tuple{MemoryViews.MemoryView{UInt8}}","page":"API reference","title":"BufferIO.line_views","text":"line_views(x::MemoryView{UInt8}; chomp::Bool=true)\n\nReturn a stateless iterator of the lines in x. The returned views are ImmutableMemoryView{UInt8} views into x. Use the package StringViews.jl to turn them into AbstractStrings.\n\nA line is defined as all data up to and including \\n (0x0a) or \\r\\n (0x0d 0x0a), or the remainder of the data in io if no \\n byte was found. If the input is empty, this iterator is also empty.\n\nThe chomp keyword (default: true), controls whether any trailing \\r\\n or \\n should be removed from the output.\n\nExamples\n\njulia> mem = MemoryView(\"abc\\r\\ndef\\nab\\n\");\n\njulia> foreach(i -> println(repr(String(i))), line_views(mem))\n\"abc\"\n\"def\"\n\"ab\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.read_all!-Tuple{AbstractBufReader, MemoryViews.MutableMemoryView{UInt8}}","page":"API reference","title":"BufferIO.read_all!","text":"read_all!(io::AbstractBufReader, dst::MutableMemoryView{UInt8})::Int\n\nRead bytes into dst until either dst is filled or io is EOF, returning the number of bytes read.\n\nExamples\n\njulia> reader = BufReader(IOBuffer(\"abcdefgh\"), 3);\n\njulia> v = zeros(UInt8, 10);\n\njulia> read_all!(reader, MemoryView(v))\n8\n\njulia> String(v)\n\"abcdefgh\\0\\0\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.read_into!-Tuple{AbstractBufReader, MemoryViews.MutableMemoryView{UInt8}}","page":"API reference","title":"BufferIO.read_into!","text":"read_into!(x::AbstractBufReader, dst::MutableMemoryView{UInt8})::Int\n\nRead bytes into the beginning of dst, returning the number of bytes read. This function will always read at least 1 byte, except when dst is empty, or x is EOF.\n\nThis function is defined generically for AbstractBufReader. New methods should strive to do at most one read call to the underlying IO, if x wraps such an IO.\n\nExamples\n\njulia> reader = CursorReader(\"abcde\");\n\njulia> v = zeros(UInt8, 8);\n\njulia> read_into!(reader, MemoryView(v))\n5\n\njulia> println(v)\nUInt8[0x61, 0x62, 0x63, 0x64, 0x65, 0x00, 0x00, 0x00]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.resize_buffer-Tuple{BufWriter, Int64}","page":"API reference","title":"BufferIO.resize_buffer","text":"resize_buffer(io::Union{BufWriter, BufReader}, n::Int) -> io\n\nResize the internal buffer of io to exactly n bytes.\n\nThrow an ArgumentError if n is less than 1, or lower than the currently number of buffered bytes (length of get_unflushed for BufWriter, length of get_buffer for BufReader).\n\njulia> w = BufWriter(IOBuffer());\n\njulia> write(w, \"abc\")\n3\n\njulia> length(get_buffer(resize_buffer(w, 5)))\n2\n\njulia> resize_buffer(w, 2)\nERROR: ArgumentError: Buffer size smaller than current number of buffered bytes\n[...]\n\njulia> shallow_flush(w)\n3\n\njulia> resize_buffer(w, 2) === w\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.shallow_flush-Tuple{BufWriter}","page":"API reference","title":"BufferIO.shallow_flush","text":"shallow_flush(io::AbstractBufWriter)::Int\n\nClear the buffer(s) of io by writing to the underlying I/O, but do not flush the underlying I/O. Return the number of bytes flushed.\n\nThis function is not generically defined for AbstractBufReader.\n\njulia> io = IOBuffer();\n\njulia> wtr = BufWriter(io);\n\njulia> write(wtr, \"hello!\");\n\njulia> take!(io)\nUInt8[]\n\njulia> shallow_flush(wtr)\n6\n\njulia> String(take!(io))\n\"hello!\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.skip_exact-Tuple{AbstractBufReader, Integer}","page":"API reference","title":"BufferIO.skip_exact","text":"skip_exact(io::AbstractBufReader, n::Integer)::Nothing\n\nLike skip, but throw an IOError of kind IOErrorKinds.EOF if n bytes could not be skipped.\n\nSee also: Base.skip\n\nExamples\n\njulia> reader = CursorReader(\"abcdefghij\");\n\njulia> position(reader)\n0\n\njulia> skip_exact(reader, 3)\n\njulia> read(reader, 2) |> String\n\"de\"\n\njulia> skip_exact(reader, 6) # 5 bytes remaining\nERROR: End of file\n\n\n\n\n\n","category":"method"},{"location":"reference/#BufferIO.IOErrorKinds.IOErrorKind","page":"API reference","title":"BufferIO.IOErrorKinds.IOErrorKind","text":"IOErrorKind\n\nEnum indicating what error was thrown. The current list is non-exhaustive, and more may be added in future releases. The integral value of these enums are subject to change in minor versions.\n\nCurrent errors:\n\nConsumeBufferError: Occurs when calling consume with a negative amount of bytes, or with more bytes than length(get_buffer(io))\nEOF: Occurs when trying a reading operation on a file that has reached end-of-file\nBufferTooShort: Thrown by various functions that require a minimum buffer size, which the io cannot provide. This should only be thrown if the buffer is unable to grow to the required size, and not if e.g. the buffer does not expand because the io is EOF.\nBadSeek: An out-of-bounds seek operation was attempted\nPermissionDenied: Acces was denied to a system (filesystem, network, OS, etc.) resource\nNotFound: Resource was not found, e.g. no such file or directory\nBrokenPipe: The operation failed because a pipe was broken. This typically happens when  writing to stdout or stderr, which then gets closed.\nAlreadyExists: Resource (e.g. file) could not be created because it already exists\nNotADirectory: Resource is unexpectedly not a directory. E.g. a path contained a non-directory file as an intermediate component.\nIsADirectory: Resource is a directory when a non-directory was expected\nDirectoryNotEmpty: Operation cannot succeed because it requires an empty directory\nInvalidFileName: File name was invalid for platform, e.g. too long name, or invalid characters.\nClosedIO: Indicates an operation was done on a closed IO.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BufferIO.IOErrorKinds","page":"API reference","title":"BufferIO.IOErrorKinds","text":"module IOErrorKinds\n\nUsed as a namespace for IOErrorKind.\n\n\n\n\n\n","category":"module"},{"location":"reference/#Base.unsafe_read-Tuple{AbstractBufReader, Any, UInt64}","page":"API reference","title":"Base.unsafe_read","text":"unsafe_read(io::AbstractBufReader, ref, nbytes::UInt)::Int\nunsafe_read(io::AbstractBufReader, p::Ptr{UInt8}, nbytes::UInt)::Int\n\nCopy nbytes from io into ref, returning the number of bytes copied. If io reached end of file, stop at EOF. ref is converted to a pointer using cref = Base.cconvert(Ptr, ref), then Base.unsafe_convert(Ptr{UInt8}, cref).\n\nSafety: The user must ensure that\n\nThe resulting pointer is valid, and points to at least nbytes of writeable memory.\nGC.@preserveing cref pins ref in memory, i.e. the pointer will not become invalid during the GC.@preserve block.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.readavailable-Tuple{AbstractBufReader}","page":"API reference","title":"Base.readavailable","text":"readavailable(io::AbstractBufReader)::Vector{UInt8}\n\nRead the available bytes of io to a new Vector{UInt8}, except if zero bytes are available. In that case, it will attempt to get more bytes exactly once. If still no bytes are available, io is EOF, and the resulting vector is empty.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.peek-Tuple{AbstractBufReader, Type{UInt8}}","page":"API reference","title":"Base.peek","text":"peek(io::AbstractBufReader)::UInt8\n\nGet the next UInt8 in io, without advancing io, or throw an IOError containing IOErrorKinds.EOF if io is EOF.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.read-Tuple{AbstractBufReader, Type{UInt8}}","page":"API reference","title":"Base.read","text":"read(io::AbstractBufReader, UInt8)::UInt8\n\nGet the next UInt8 in io, or throw an IOError containing IOErrorKinds.EOF if io is EOF.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.readbytes!","page":"API reference","title":"Base.readbytes!","text":"readbytes!(io::AbstractBufReader, b::AbstractVector{UInt8}, nb::Integer=length(b))::Int\n\nRead at most nb bytes from io into b, returning the number of bytes read. This function will read zero bytes if and only if io is EOF.\n\nb must use one-based indexing. The size of b will be increased if needed (i.e. if nb is greater than length(b) and enough bytes could be read), but it will never be decreased.\n\nIt is generally preferred to use read_into! instead of this method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.copyline-Tuple{Union{AbstractBufWriter, IO}, AbstractBufReader}","page":"API reference","title":"Base.copyline","text":"copyline(\n    out::Union{IO, AbstractBufWriter},\n    from::AbstractBufReader;\n    keep::Bool = false\n) -> out\n\nCopy one line from from to out, returning out. A line is defined as data up to and including \\n (byte 0x0a), or all remaining data in from if no such byte is present.\n\nIf keep is false, as it is by default, the trailing \\r\\n (encoded as 0x0d 0x0a) or \\n will not be copied to out, but it will be consumed from from.\n\nThis function may throw an IOerror with IOErrorKinds.BufferTooShort, if all the following occurs:\n\nkeep is false\nThe reader has a buffer size of 1\nThe reader cannot expand its buffer\nThe only byte in the buffer is \\r (0x0d). \n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.filesize-Tuple{CursorReader}","page":"API reference","title":"Base.filesize","text":"filesize(io::AbstractBufReader)::Int\n\nGet the total size, in bytes, which can be read by io, and the span in which io can be seeked. Types implementing filesize should also implement seek.\n\nThe filesize does not depend on the current reading state of the io, i.e. reading bytes should not change the filesize.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.filesize-Tuple{BufWriter}","page":"API reference","title":"Base.filesize","text":"filesize(io::AbstractBufWriter)::Int\n\nGet the filesize of io, in bytes.\n\nThe filesize is understood as the number of bytes flushed to the underlying resource of io, and which can be retrived by re-reading the data (so e.g. some streams like devnull may have a filesize of zero, even if many bytes was flushed to it.) The filesize does not depend on, and does not include, the number of buffered and unflushed bytes.\n\nTypes implementing filesize should also implement seek and position.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.seek-Tuple{BufReader, Int64}","page":"API reference","title":"Base.seek","text":"seek(io::AbstractBufReader, offset::Int) -> io\n\nSeek io to the zero-based position offset, if io supports seeking, and return io. When offset === 0, this is equivalent to seekstart. If filesize(io) is implemented, seek(io, filesize(io)) is equivalent to seekend(io).\n\nValid offsets are 0:filesize(io), if io implements filesize. Seeking outside these bounds throws an IOError of kind BadSeek.\n\nThis method is not generically defined for AbstractBufReader.\n\njulia> rdr = BufReader(IOBuffer(\"Hello, world!\"));\n\njulia> String(read(rdr, 5))\n\"Hello\"\n\njulia> seek(rdr, 3);\n\njulia> String(read(rdr, 5))\n\"lo, w\"\n\njulia> seek(rdr, 13);\n\njulia> read(rdr)\nUInt8[]\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.seek-Tuple{BufWriter, Int64}","page":"API reference","title":"Base.seek","text":"seek(io::AbstractBufWriter, offset::Int) -> io\n\nFlush io, then seek io to the zero-based position offset.\n\nValid values for offset are in 0:filesize(io), if filesize(io) is defined. The filesize  is computed after the flush. Seeking outside these bounds throws an IOError of kind BadSeek. Seeking should only change the filesize through its flush, so seeking an already-flushed stream should not change the filesize.\n\nIf seeking to before the current position (as defined by position), data between the new and the previous position need not be changed, and the underlying file or IO need not immediately be truncated. However, new write operations should write (or overwrite) data at the new position.\n\nThis method is not generically defined for AbstractBufWriter. Implementors of seek should also define filesize(io) and position(io)\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.position-Tuple{BufWriter}","page":"API reference","title":"Base.position","text":"Base.position(io::AbstractBufWriter)::Int\n\nGet the zero-based stream position.\n\nIf the stream position is p (zero-based), then the next byte written will be byte number p + 1 (one-based) in the file. The stream position does account for buffered (consumed, but unflushed) bytes, and therefore may exceed filesize. After calling flush, position must be in 0:filesize(io), if filesize is defined.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.position-Tuple{CursorReader}","page":"API reference","title":"Base.position","text":"Base.position(io::AbstractBufReader)::Int\n\nGet the zero-based stream position.\n\nIf the stream position is p (zero-based), then the next byte read will be byte number p + 1 (one-based). The value of position must be in 0:filesize(io), if filesize is defined.\n\nExamples\n\njulia> reader = CursorReader(\"abcdefghij\");\n\njulia> position(reader) # zero-indexed\n0\n\njulia> read(reader, 3) |> String\n\"abc\"\n\njulia> position(reader)\n3\n\njulia> read(reader, 2) |> String\n\"de\"\n\njulia> position(reader)\n5\n\njulia> seekstart(reader); position(reader)\n0\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.skip-Tuple{AbstractBufReader, Int64}","page":"API reference","title":"Base.skip","text":"skip(io::AbstractBufReader, n::Integer)::Int\n\nRead n bytes from io, or until EOF, whichever comes first, and discard the read bytes. Return the number of bytes read.\n\nThis function is defined generically for AbstractBufReader by reading bytes, not by seeking. Subtypes of AbstractBufReader may implement this using seeking. In order to skip a generic AbstractBufReader and guarantee seeking is used, use seek(io, position(io) + n).\n\nThrows an ArgumentError if n < 0.\n\nSee also: skip_exact\n\nExamples\n\njulia> reader = CursorReader(\"abcdefghij\");\n\njulia> skip(reader, 5)\n5\n\njulia> read(reader, 3) |> String\n\"fgh\"\n\njulia> skip(reader, 10) # 2 bytes remaining\n2\n\njulia> eof(reader)\ntrue\n\njulia> skip(reader, 100)\n0\n\n\n\n\n\n","category":"method"},{"location":"#BufferIO.jl","page":"BufferIO","title":"BufferIO.jl","text":"BufferIO provides new and improved I/O interfaces for Julia inspired by Rust, and designed around exposing buffers to users in order to explicitly copy bytes to and from them. Compared to the Base.IO interface, the new interfaces in this package are:\n\nLower level and faster\nBetter specified, with more well-defined semantics and therefore easier to reason about\nFree from slow fallback methods that silently trash your performance\n\nBeside the new interfaces, BufferIO also provides a small set of basic types to make use of the new interface, and/or allow easy interoperation between Base.IO types and the new buffered interfaces.","category":"section"},{"location":"#Overview-of-content:","page":"BufferIO","title":"Overview of content:","text":"AbstractBufReader: A reader type that exposes its internal data as an immutable memory view of bytes\nAbstractBufWriter: A writer type that allows writing to it by copying data to a mutable memory view of its internal buffer\nBufReader: An AbstractBufReader that wraps a Base.IO\nBufWriter: An AbstractBufWriter type that wraps a Base.IO\nCursorReader: An AbstractBufReader that wraps any contiguous, memory of bytes into a stateful reader\nIOReader: A Base.IO type that wraps an AbstractBufReader\nIOWriter: A Base.IO type that wraps an AbstractBufWriter\nVecWriter: An AbstractBufWriter type that is a faster and simpler alternative to IOBuffer usable e.g. to build strings.","category":"section"},{"location":"#Examples","page":"BufferIO","title":"Examples","text":"See the page with Example use of BufferIO in the sidebar to the left, or take a look at the docstrings of functions.","category":"section"},{"location":"#Design-notes-and-limitations","page":"BufferIO","title":"Design notes and limitations","text":"","category":"section"},{"location":"#Requires-Julia-1.11","page":"BufferIO","title":"Requires Julia 1.11","text":"BufferIO relies heavily on the Memory type and associated types introduced in 1.11 for its buffers","category":"section"},{"location":"#**Not**-threadsafe-by-default","page":"BufferIO","title":"Not threadsafe by default","text":"Locks introduce unwelcome overhead and defeats the purpose of low-level control of your IO. Wrap your IO in a lock if you need thread safety.","category":"section"},{"location":"#Separate-readers-and-writers","page":"BufferIO","title":"Separate readers and writers","text":"Unlike Base.IO which encompasses both readers and writers, this package has two distinct interfaces for AbstractBufReader and AbstractBufWriter. This simplifies the interface for most types.\n\nIn the unlikely case someone wants to create a type which is both, you can create a base type T, wrapper types R <: AbstractBufReader and W <: AbstractBufWriter and then implement reader(::T)::R and writer(::T)::W.","category":"section"},{"location":"#Limitations-on-working-with-strings","page":"BufferIO","title":"Limitations on working with strings","text":"String is special-cased in Julia, which makes several important optimisations impossible in an external package. Hopefully, these will be removed in future versions of Julia:\n\nCurrently, reading from a String allocates. This is because strings are currently not backed by Memory and therefore cannot present a MemoryView. Constructing a memory view from a string requires allocating a new Memory object. Fortunately, the allocation is small since string need not be copied, but can share storage with the Memory.","category":"section"},{"location":"#Julia-compiler-limitation","page":"BufferIO","title":"Julia compiler limitation","text":"This package makes heavy use of union-typed return values. These currently have no ABI support in Julia, which makes this package significantly less efficient. That limitation will almost certainly be lifted in a future release of Julia.","category":"section"},{"location":"writers/#AbstractBufWriter","page":"Writers","title":"AbstractBufWriter","text":"","category":"section"},{"location":"writers/#Core,-low-level-interface","page":"Writers","title":"Core, low-level interface","text":"Similar to AbstractBufReader, the core interface of AbstractBufWriter consists of three functions:\n\nget_buffer(io) returns a mutable view into the part of the buffer which is not yet used. Data is written to io by copying to the first bytes of the buffer, then calling consume.\ngrow_buffer(io) request to expand the buffer returned by future calls to get_buffer. This may happen by flushing data in the buffer or by reallocating a larger buffer\nconsume(io, n::Int) signals that the first n bytes in the buffer are written to io, and will therefore not be returned from future calls to get_buffer.","category":"section"},{"location":"writers/#Example:-Writing-v::Vector{UInt8}-to-an-AbstractBufWriter","page":"Writers","title":"Example: Writing v::Vector{UInt8} to an AbstractBufWriter","text":"The method write(::AbstractBufWriter, v::Vector{UInt8}) is already implemented, but it's illustrative to see how this be implemented in terms of the core primitives above.\n\nFirst, let's define it in terms of ImmutableMemoryView, and then forward the Vector method to the memory one.\n\nusing MemoryViews\n\n# Forward the vector method to a memory view method\nmy_write(io::AbstractBufWriter, v::Vector{UInt8}) = my_write(io, ImmutableMemoryView(v))\n\nfunction my_write(io::AbstractBufWriter, mem::ImmutableMemoryView{UInt8})::Int\n    n_bytes = length(mem)\n    while !isempty(mem)\n        # Get mutable buffer with uninitialized data to write to\n        buffer = get_buffer(io)::MutableMemoryView{UInt8}\n        if isempty(buffer)\n            # grow_buffer cannot return `nothing`, unlike for readers, but the writer\n            # may still be unable to add more bytes (in which case grow_buffer returns\n            # zero). A real implementation would use a better error\n            iszero(grow_buffer(io)) && error(\"Could not flush\")\n            buffer = get_buffer(io)::MutableMemoryView{UInt8}\n        end\n        mn = min(length(mem), length(buffer))\n        # This would indicate an error in the implementation of `grow_buffer`.\n        # As it did not return zero, the buffer must have grown.\n        @assert !iszero(mn)\n        (to_write, mem) = split_at(mem, mn + 1)\n        copyto!(buffer[1:mn], to_write)\n        # Mark the first `mn` bytes of the buffer as being committed, thereby\n        # actually writing it to `io`\n        consume(io, mn)\n    end\n    return n_bytes\nend","category":"section"},{"location":"writers/#Notable-AbstractWriter-functions","page":"Writers","title":"Notable AbstractWriter functions","text":"","category":"section"},{"location":"writers/#BufferIO.get_buffer-writers","page":"Writers","title":"BufferIO.get_buffer","text":"get_buffer(io::AbstractBufReader)::ImmutableMemoryView{UInt8}\n\nGet the available bytes of io.\n\nCalling this function, even when the buffer is empty, should never do actual system I/O, and in particular should not attempt to fill the buffer. To fill the buffer, call fill_buffer.\n\nExamples\n\njulia> reader = BufReader(IOBuffer(\"abcdefghij\"), 5);\n\njulia> get_buffer(reader) |> isempty\ntrue\n\njulia> fill_buffer(reader)\n5\n\njulia> get_buffer(reader) |> println\nUInt8[0x61, 0x62, 0x63, 0x64, 0x65]\n\n\n\n\n\nget_buffer(io::AbstractBufWriter)::MutableMemoryView{UInt8}\n\nGet the available mutable buffer of io that can be written to.\n\nCalling this function should never do actual system I/O, and in particular should not attempt to flush data from the buffer or grow the buffer. To increase the size of the buffer, call grow_buffer.\n\nExamples\n\njulia> writer = BufWriter(IOBuffer(), 5);\n\njulia> buffer = get_buffer(writer);\n\njulia> (typeof(buffer), length(buffer))\n(MutableMemoryView{UInt8}, 5)\n\njulia> write(writer, \"abcde\")\n5\n\njulia> get_buffer(writer) |> isempty\ntrue\n\njulia> flush(writer)\n\njulia> buffer = get_buffer(writer); length(buffer)\n5\n\n\n\n\n\n","category":"function"},{"location":"writers/#BufferIO.grow_buffer-writers","page":"Writers","title":"BufferIO.grow_buffer","text":"grow_buffer(io::AbstractBufWriter)::Int\n\nIncrease the amount of bytes in the writeable buffer of io if possible, returning the number of bytes added. After calling grow_buffer and getting n, the buffer obtained by get_buffer should have n more bytes.\n\nThe buffer is usually grown by flushing the buffer, expanding or reallocating the buffer. If none of these can grow the buffer, return zero.\n\nnote: Note\nIdiomatically, users should not call grow_buffer when the buffer is not empty, because doing so forces growing the buffer instead of letting io choose an optimal buffer size. Calling grow_buffer with a nonempty buffer is only appropriate if, for algorithmic reasons you need io buffer to be able to hold some minimum amount of data before flushing.\n\nExamples\n\njulia> v = VecWriter(undef, 0); get_buffer(v) |> isempty\ntrue\n\njulia> n_grown = grow_buffer(v); n_grown > 0\ntrue\n\njulia> length(get_buffer(v)) == n_grown\ntrue\n\n\n\n\n\n","category":"function"},{"location":"writers/#BufferIO.consume-writers","page":"Writers","title":"BufferIO.consume","text":"consume(io::Union{AbstractBufReader, AbstractBufWriter}, n::Int)::Nothing\n\nRemove the first n bytes of the buffer of io. Consumed bytes will not be returned by future calls to get_buffer.\n\nIf n is negative, or larger than the current buffer size, throw an IOError with ConsumeBufferError kind. This check is a boundscheck and may be elided with @inbounds.\n\nExamples\n\njulia> reader = CursorReader(\"abcdefghij\");\n\njulia> get_buffer(reader) == b\"abcdefghij\"\ntrue\n\njulia> consume(reader, 8); get_buffer(reader) |> println\nUInt8[0x69, 0x6a]\n\njulia> consume(reader, 3) # 2 bytes remaining\nERROR: Called `consume` with a negative amount, or larger than available buffer size\n\n\n\n\n\n","category":"function"},{"location":"writers/#BufferIO.get_unflushed-writers","page":"Writers","title":"BufferIO.get_unflushed","text":"get_unflushed(io::AbstractBufWriter)::MutableMemoryView{UInt8}\n\nReturn a view into the buffered data already written to io and consumed, but not yet flushed to its underlying IO.\n\nBytes not appearing in the buffer may not be completely flushed if there are more layers of buffering in the IO wrapped by io. However, any bytes already consumed and not returned in get_unflushed should not be buffered in io itself.\n\nMutating the returned buffer is allowed, and should not cause io to malfunction. After mutating the returned buffer and calling flush, values in the updated buffer will be flushed.\n\nThis function has no default implementation and methods are optionally added to subtypes of AbstractBufWriter that can fullfil the above restrictions.\n\nExamples\n\njulia> io = IOBuffer(); writer = BufWriter(io);\n\njulia> isempty(get_unflushed(writer))\ntrue\n\njulia> write(writer, \"abc\"); unflushed = get_unflushed(writer);\n\njulia> println(unflushed)\nUInt8[0x61, 0x62, 0x63]\n\njulia> unflushed[2] = UInt8('x')\n0x78\n\njulia> flush(writer); take!(io) |> println\nUInt8[0x61, 0x78, 0x63]\n\njulia> get_unflushed(writer) |> isempty\ntrue\n\n\n\n\n\n","category":"function"},{"location":"writers/#BufferIO.get_nonempty_buffer-Tuple{VecWriter, Int64}-writers","page":"Writers","title":"BufferIO.get_nonempty_buffer","text":"get_nonempty_buffer(\n    io::AbstractBufWriter, min_size::Int\n)::Union{Nothing, MutableMemoryView{UInt8}}\n\nGet a buffer of at least size max(min_size, 1), or nothing if that is not possible.\n\nThis method is optionally implemented for subtypes of AbstractBufWriter, and is typically only implemented for types which do not flush their data to an underlying IO, such that there is no memory savings by writing in smaller chunks.\n\nwarning: Warning\nUse of this method may cause excessive buffering without flushing, which is less memory efficient than calling the one-argument method and flushing in a loop.\n\nExamples\n\njulia> function write_int_le(writer::AbstractBufWriter, int::Int64)\n           buf = get_nonempty_buffer(writer, sizeof(Int64))::Union{Nothing, MutableMemoryView{UInt8}}\n           isnothing(buf) && throw(IOError(IOErrorKinds.BufferTooShort))\n           length(buf) < sizeof(Int64) && error(\"Bad implementation of get_nonempty_buffer\")\n           GC.@preserve buf unsafe_store!(Ptr{Int64}(pointer(buf)), htol(int))\n           @inbounds consume(writer, sizeof(Int64))\n           return sizeof(Int64)\n       end;\n\njulia> v = VecWriter(); write_int_le(v, Int64(515))\n8\n\njulia> String(v.vec)\n\"\\x03\\x02\\0\\0\\0\\0\\0\\0\"\n\n\n\n\n\n","category":"method"},{"location":"types/#Pre-defined-types","page":"Types","title":"Pre-defined types","text":"","category":"section"},{"location":"types/#BufReader","page":"Types","title":"BufReader","text":"","category":"section"},{"location":"types/#BufWriter","page":"Types","title":"BufWriter","text":"","category":"section"},{"location":"types/#IOReader","page":"Types","title":"IOReader","text":"","category":"section"},{"location":"types/#IOWriter","page":"Types","title":"IOWriter","text":"","category":"section"},{"location":"types/#CursorReader","page":"Types","title":"CursorReader","text":"","category":"section"},{"location":"types/#VecWriter","page":"Types","title":"VecWriter","text":"","category":"section"},{"location":"types/#BufferIO.BufReader-types","page":"Types","title":"BufferIO.BufReader","text":"BufReader{T <: IO} <: AbstractBufReader\nBufReader(io::IO, [buffer_size::Int])::BufReader\n\nWrap an IO in a struct with a new buffer, giving it the AbstractBufReader interface.\n\nThe BufReader has an infinitely growable buffer, and will only grow the buffer if fill_buffer is called while its internal buffer is full.\n\nThrow an ArgumentError if buffer_size is less than 1.\n\njulia> rdr = BufReader(IOBuffer(\"Hello, world!\\nabc\\r\\ndef\"));\n\njulia> get_buffer(rdr) |> isempty\ntrue\n\njulia> peek(rdr)\n0x48\n\njulia> readline(rdr)\n\"Hello, world!\"\n\njulia> String(readavailable(rdr))\n\"abc\\r\\ndef\"\n\n\n\n\n\n","category":"type"},{"location":"types/#BufferIO.BufWriter-types","page":"Types","title":"BufferIO.BufWriter","text":"BufWriter{T <: IO} <: AbstractBufWriter\nBufWriter(io::IO, [buffer_size::Int])::BufWriter\n\nWrap an IO in a struct with a new buffer, giving it the AbstractBufWriter interface.\n\nThe BufWriter has an infinitely growable buffer, and will only expand the buffer if grow_buffer is called on it while it does not contain any data (as shown by get_unflushed).\n\nThrow an ArgumentError if buffer_size is < 1.\n\njulia> io = IOBuffer(); wtr = BufWriter(io);\n\njulia> print(wtr, \"Hello!\")\n\njulia> write(wtr, [0x1234, 0x5678])\n4\n\njulia> isempty(read(io)) # wtr not flushed\ntrue\n\njulia> flush(wtr); seekstart(io); String(read(io))\n\"Hello!4\\x12xV\"\n\njulia> isempty(get_unflushed(wtr))\ntrue\n\n\n\n\n\n","category":"type"},{"location":"types/#BufferIO.IOReader-types","page":"Types","title":"BufferIO.IOReader","text":"IOReader{T <: AbstractBufReader} <: IO\n\nWrapper type to convert an AbstractBufReader to an IO.\n\nIOReaders implement the same part of the IO interface as AbstractBufReader, so this type is only used to satisfy type constraints.\n\nExamples\n\njulia> io = CursorReader(\"hello\");\n\njulia> f(x::IO) = String(read(x));\n\njulia> f(io)\nERROR: MethodError: no method matching f(::CursorReader)\n[...]\n\njulia> f(IOReader(io))\n\"hello\"\n\n\n\n\n\n","category":"type"},{"location":"types/#BufferIO.IOWriter-types","page":"Types","title":"BufferIO.IOWriter","text":"IOWriter{T <: AbstractBufWriter} <: IO\n\nWrapper type to convert an AbstractBufWriter to an IO.\n\nIOWriters implement the same part of the IO interface as AbstractBufWriter, so this type is only used to satisfy type constraints.\n\nExamples\n\njulia> io = VecWriter();\n\njulia> f(x::IO) = write(x, \"hello\");\n\njulia> f(io)\nERROR: MethodError: no method matching f(::VecWriter)\n[...]\n\njulia> f(IOWriter(io))\n5\n\njulia> String(io.vec)\n\"hello\"\n\n\n\n\n\n","category":"type"},{"location":"types/#BufferIO.CursorReader-types","page":"Types","title":"BufferIO.CursorReader","text":"CursorReader(x) <: AbstractBufReader\n\nA seekable, stateful reader of the content of any object x which implements MemoryView(x)::MemoryView{UInt8}.\n\nClosing it does nothing.\n\njulia> rdr = CursorReader(\"some\\ncontent\\nhere\");\n\njulia> readline(rdr)\n\"some\"\n\njulia> read(rdr, String)\n\"content\\nhere\"\n\njulia> seek(rdr, 8);\n\njulia> read(rdr, String)\n\"tent\\nhere\"\n\n\n\n\n\n","category":"type"},{"location":"types/#BufferIO.VecWriter-types","page":"Types","title":"BufferIO.VecWriter","text":"VecWriter <: AbstractBufWriter\n\nA writer backed by a ByteVector. Read the (public) property .vec to get the vector back.\n\nThis type is useful as an efficient string builder through takestring!(io).\n\nFunctions flush and close do not affect the writer.\n\nMutating io will mutate vec and vice versa. Neither vec nor io will be invalidated by mutating the other, but doing so may affect the implicit (non-semantic) behaviour (e.g. memory reallocations or efficiency) of the other. For example, repeated and interleaved push!(vec) and write(io, x) may be less efficient, if one operation has memory allocation patterns that is suboptimal for the other operation.\n\nCreate with one of the following constructors:\n\nVecWriter([vec::Vector{UInt8}])\nVecWriter(undef, ::Int)\nVecWriter(::ByteVector)\n\nNote that, currently, when constructing from a Vector{UInt8}, the vector is invalidated and the VecWriter and its wrapped ByteVector take shared control of the underlying memory. This restriction may be lifted in the future.\n\nA VecWriter has no notion of filesize, and cannot be seeked. Instead, resize the underlying vector io.vec.\n\njulia> vw = VecWriter();\n\njulia> write(vw, \"Hello, world!\", 0xe1fa)\n15\n\njulia> append!(vw.vec, b\"More data\");\n\njulia> String(vw.vec)\n\"Hello, world!\\xfa\\xe1More data\"\n\n\n\n\n\n","category":"type"}]
}
